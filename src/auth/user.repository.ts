import {
  ConflictException,
  InternalServerErrorException,
} from '@nestjs/common';
import { EntityRepository, Repository } from 'typeorm';
import { AuthConstants } from './constants/auth.constants';
import { AuthCredentialsDto } from './dto/auth-credentials.dto';
import { User } from './user.entity';
import * as bcrypt from 'bcrypt';

/**
 * Manages the database operations with respect to
 * the authentication of a user.
 */
@EntityRepository(User)
export class UserRepository extends Repository<User> {
  async signUp(authCredentialsDto: AuthCredentialsDto): Promise<void> {
    // Destructure the authentication credentials.
    const { password, username } = authCredentialsDto;

    // Create a new user.
    const user = this.create();

    // Assign value the username value.
    user.username = username;

    // Assign the unique salt value generated by bcrypt.
    user.salt = await bcrypt.genSalt();

    // Assign the hashed password value.
    user.password = await this.hashPassword(password, user.salt);

    try {
      // Save the new user.
      await user.save();
    } catch (error) {
      // Destructure the constants.
      const { DUPLICATE_USER_ERROR_CODE } = AuthConstants;

      if (error.code === DUPLICATE_USER_ERROR_CODE) {
        // Destructure the constants.
        const { USERNAME_ALREADY_EXISTS } = AuthConstants;

        // Throw conflict exception if the user already exists.
        throw new ConflictException(USERNAME_ALREADY_EXISTS);
      } else {
        // Throw internal server error for any other issues.
        throw new InternalServerErrorException();
      }
    }
  }

  /**
   * Validate the user password when he prompts to sign in.
   * @param authCredentialsDto Holds the authentication params.
   */
  async validateUserPassword(
    authCredentialsDto: AuthCredentialsDto,
  ): Promise<string> {
    // Destructure the authentication credentials.
    const { password, username } = authCredentialsDto;

    // Find the user entity from the database for the specified username.
    const user = await this.findOne({ username });

    if (user && (await user.validatePassword(password))) {
      // If the password matches return the username.
      return user.username;
    } else {
      return null;
    }
  }

  /**
   * Hash the password entered while signing up using a
   * salt and returns the generated hash.
   *
   * @param password Password hash stored in the database.
   * @param salt Salt stored in the database.
   */
  private async hashPassword(password: string, salt: string): Promise<string> {
    // Return the password hash.
    return await bcrypt.hash(password, salt);
  }
}
